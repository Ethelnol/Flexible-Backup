#!/bin/bash

declare -i true=0
declare -i false=1

declare conf="$HOME/.config/flexible-backup.conf"

declare archiveType="tar.gz"
declare outputDir
declare backupRoot
#whitelist and blacklist are assumed to be inside $backupDirRoot
declare -a dirWhitelist=()
declare -a dirBlacklist=()
declare -a requiredScan=()

declare -i fiveGigabytes=$((5 * (2**30)))

declare lastBackup=""

#returns true if (whitelisted input is backed up) or (whitelisted subdir is backed up)
#returns false if (no whitelisted input is backed up) or (no whitelisted subdir is backed up)
main(){
	local i
	local returnBool=$false

	cd "$backupRoot" || exit 2

	for i in "${dirWhitelist[@]}"; do

		Scan $true 0 "$i"
		if  (( $? )); then returnBool=$true; fi
		cd "$backupRoot" || exit 2
	done

	if [[ "$returnBool" == "$true" ]]
		then echo "Backup complete"; sudo chown -R "$USER:$USER" "$outputDir"
		else echo "Backup complete: No backups made"
	fi

	return $returnBool
}

#returns true if (input is backed up) or (any subdir is backed up)
#returns false if (input is blacklisted) or (input not backed up) or (no subdir is backed up)
Scan(){
	local -i checkSize=$1; shift
	local -i tabCount=$1; shift
	local i="$*"
	local j
	local -i returnBool=$false

	if [[ "$PWD" == "/" ]]
	then i="/$i"
	else i="$PWD/$i"
	fi

	EchoTabs $tabCount; echo "Scanning: \"$i\""

	#if (blacklisted)
	for j in "${dirBlacklist[@]}"; do
		#${i:1:SizeOf$j} == $j
		if [[ "${i:1:${#j}}" == "$j" ]]; then
			EchoTabs $tabCount; echo -e "Exception found.  Skipping: \"$i\"\n"
			return $false
		fi
	done

	#if (told to check size)
	if [[ "$checkSize" == "$true" ]]; then
		#if (equal or larger than 5g)
		if (( $(sudo du -sb "$i" | awk '{print $1}') > fiveGigabytes )); then
		#if [[ "$(echo -e "$SIZE\n$(( 5 * ( 2 ** 30 ) ))" | sort -V | head -1 )" == "$SIZE" ]]; then
			#if ($i is a file)
			if [[ -f "$i" ]]; then
				Backup $tabCount "$i"
				return $?
			fi

			DeeperScan $true $tabCount "$i"
			return $?
		fi
	fi

	#if (has blacklisted subdir)
	for j in "${dirBlacklist[@]}"; do
		#/${j:0:SizeOf$i} == $i
		if [[ "/${j:0:$(( ${#i} - 1 ))}" == "$i" ]]; then
			DeeperScan $false $tabCount "$i"
			return $?
		fi
	done

	#if (is requiredScan dir) or (has requiredScan subdir)
	for j in "${requiredScan[@]}"; do
		#/${j:0:SizeOf$i} == $i
		if [[ "/${j:0:$(( ${#i} - 1 ))}" == "$i" ]]; then
			DeeperScan $false $tabCount "$i"
			return $?
		fi
	done

	Backup $tabCount "$i"
	return $?
}

#returns true if (any subdir is backed up)
#returns false if (no subdir is backed up)
DeeperScan(){
	local -i checkSize=$1; shift
	local -i tabCount=$1; shift
	local i="$*"
	local j
	local returnBool=$false
	local -a curdirSubdirs 

	cd "$i" || exit 2

	set -o noglob
	mapfile -t curdirSubdirs < <(sudo ls -a)

	for j in "${curdirSubdirs[@]}"; do
		if [[ "$j" == "." ]] || [[ "$j" == ".." ]]; then continue; fi
		
		Scan $checkSize $((tabCount+1)) "$j"
		if [[ "$?" == "$true" ]]; then returnBool=$true; fi

		cd "$i" || exit 2
	done

	return $returnBool
}

#returns true if (runs backup)
#returns false if (does not run backup)
Backup(){
	local -i tabCount=$1; shift
	local i="$*"

	#if destination archive (doesn't exist) or (is older than the source)
	if WriteOrNot "$i"; then
		EchoTabs $tabCount; echo "Backing up: \"$i\""

		#if (archive exists)
		if [[ -f "$outputDir$i.$archiveType" ]]; then
			sudo rm "$outputDir$i.$archiveType"
		fi
		
		#if ($i isn't in backupRoot)
		if [[ "$(dirname "$i")" != "$backupRoot" ]]; then
			sudo mkdir -p "$outputDir$(dirname "$i")" 2> /dev/null
		fi

		Compress "$i"

		EchoTabs $tabCount; echo -e "Backed up: \"$i\"\n"
		return $true
	fi

	EchoTabs $tabCount; echo -e "Backup unnecessary.  Skipping: \"$i\"\n"
	return $false
}

#returns true if (destination archive does not exist) or (destination archive is older than source)
#returns false if (destination archive is younger than source)
WriteOrNot(){
	local checkSource="$*"

	if [[ ! -f "$outputDir$checkSource.$archiveType" ]]; then
		return $true
	fi

	local -i fileTime; fileTime="$(date -r "$checkSource" "+%Y%m%d%H%M%S")"
	local -i archiveTime; archiveTime="$(date -r "$outputDir$checkSource.$archiveType" "+%Y%m%d%H%M%S")"

	if (( fileTime > archiveTime ))
		then return $true
		else return $false
	fi
}

Compress(){
	local i="$*"

	lastBackup="$outputDir$i.$archiveType"

	(\
		sudo tar --absolute-names --directory "$(sudo dirname "$i")" --create --file - "$(sudo basename "$i")" |\
		pv --byte --rate --timer --progress --eta --size "$(\
			sudo du -sb "$i" | awk '{print $1}'\
		)" |\
		sudo gzip --keep --quiet --best --stdout |\
		sudo tee "$outputDir$i.$archiveType" &> /dev/null
	)
}

EchoTabs(){
	local -i num=$1
	local -i i
	for ((i=0; i<num; i++)); do
		echo -ne "\t"
	done
}

#returns true if (user is root) or (user executes sudo)
#returns false if (user cannot execute sudo) or (user does not execute sudo)
SudoCheck(){
	if [[ "$(whoami)" != "root" ]]; then
		(sudo -l &> /dev/null) && sudo echo -e "Sudo privileges verified\n" && return $true

		echo -e "Error: requires sudo privileges\n"; return $false
	fi
	return $true
}

CheckConf(){
	if [[ -f "$conf" ]];
		then ReadConf; return $true
		else MakeConf; return $false
	fi
}

ReadConf(){
	
	. "$HOME/.config/flexible-backup.conf"

	IFS=","

	backupRoot="$BackupRootDir"
	if [[ "${backupRoot:0:1}" != "/" ]]; then backupRoot="/$backupRoot"; fi
	if [[ "${backupRoot:0-1}" == "/" ]] && [[ "$backupRoot" != "/" ]]
		then backupRoot="${backupRoot:0:0-1}"; fi
	
	outputDir="$OutputLocation"
	if [[ "${outputDir:0:1}" != "/" ]]; then outputDir="/$outputDir"; fi
	if [[ "${outputDir:0-1}" == "/" ]] && [[ "$outputDir" != "/" ]]
		then outputDir="${outputDir:0:0-1}"; fi

	read -ra dirWhitelist <<< "$Whitelist"

	for i in "${!dirWhitelist[@]}"; do
		if [[ "${dirWhitelist[i]:0:1}" == "/" ]]; then dirWhitelist[i]="${dirWhitelist[$i]:1}"; fi
		if [[ "${dirWhitelist[i]:0-1}" == "/" ]]; then dirWhitelist[i]="${dirWhitelist[$i]:0:0-1}"; fi
	done

	read -ra dirBlacklist <<< "$Blacklist"

	for i in "${!dirBlacklist[@]}"; do
		if [[ "${dirBlacklist[i]:0:1}" == "/" ]]; then dirBlacklist[i]="${dirBlacklist[$i]:1}"; fi
		if [[ "${dirBlacklist[i]:0-1}" == "/" ]]; then dirBlacklist[i]="${dirBlacklist[$i]:0:0-1}"; fi
	done
	dirBlacklist+=("${outputDir:1}")

	read -ra requiredScan <<< "$SplinteredBackupRequired"

	for i in "${!requiredScan[@]}"; do
		if [[ "${requiredScan[i]:0:1}" == "/" ]]; then requiredScan[i]="${requiredScan[i]:1}"; fi
		if [[ "${requiredScan[i]:0-1}" == "/" ]]; then requiredScan[i]="${requiredScan[i]:0:0-1}"; fi
	done
	
	unset BackupRoot
	unset OutputLocation
	unset Whitelist
	unset Blacklist
	unset SplinteredBackupRequired

	#echo -ne "$backupRoot\n$outputDir\n"; for i in "${dirWhitelist[@]}"; do echo -n "$i,"; done; echo ""; for i in "${dirBlacklist[@]}"; do echo -n "$i,"; done; echo ""; for i in "${requiredScan[@]}"; do echo -n "$i,"; done; echo ""
}

MakeConf(){
	sudo touch "$conf"
	sudo cat "$(dirname -- "$0")/flexible-backup.conf.example" | sudo tee "$conf" &> /dev/null
	sudo chmod 600 "$conf"
	sudo chown "$USER:$USER" "$conf"

	echo "Config file made"
	echo "Config can be found and editted at \"$conf\""
}

# shellcheck disable=SC2317
SIGINT_Cleanup(){
	if [[ -f "$lastBackup" ]]; then
		echo "Program canceled, cleaning up $lastBackup"
		sudo rm "$lastBackup"
	fi
}

#has command handle SIGINT itself
trap 'SIGINT_Cleanup;exit 1' INT

SudoCheck && CheckConf && main
exit $?