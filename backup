#!/bin/bash
declare -ri fiveGigabytes=$((5 * (2**30)))

declare noByteDU=false
declare -r conf="$HOME/.config/flexible-backup.conf"
declare archiveType="gz"

declare outputDir
declare backupRoot
#whitelist and blacklist are assumed to be inside $backupDirRoot
declare -a dirWhitelist=()
declare -a dirBlacklist=()
declare -a requiredScan=()
declare -i quietLevel=0
declare verbose=false
declare pvOpts=""
declare dryRun=false

declare -i totalSize=0
declare -i decimalOfTotalSize=0
declare -i sigFigs=2
declare -i lastBackupSize=0
declare lastBackup=""

#returns 0 if (whitelisted input is backed up) or (subdir of whitelisted input is backed up)
#returns 1 if (no whitelisted input is backed up) or (no subdir of whitelisted input is backed up)
main(){
	local i
	local returnBool=false

	cd "$backupRoot" || exit 2

	#if ($OSTYPE is darwin)
	if [[ "${OSTYPE:0:6}" == "darwin" ]]; then noByteDU=true; fi

	for i in "${dirWhitelist[@]}"; do
		if Scan true 0 "$i"; then returnBool=true; fi
		
		cd "$backupRoot" || exit 2
	done


	if (( quietLevel < 2 )); then echo ""; fi
	echo -n "Backup complete"
	if $returnBool; then
		echo ""; sudo chown -R "$USER:$USER" "$outputDir"
		GetTotalSizeBackedUp
		return 0
	else
		echo ": No backups made"
		return 1
	fi
}

#returns 0 if (input is backed up) or (any subdir of input is backed up)
#returns 1 if (input is blacklisted) or (input not backed up) or (no subdir of input is backed up)
#param $1 is bool
#param $2 is int
#param $* are arr elements
Scan(){
	local checkSize
	if [[ $1 == "true" ]]
		then checkSize=true
		else checkSize=false
	fi
	local -i tabCount=$2; shift 2
	local i="$*"

	local j

	if [[ "$PWD" == "/" ]]
		then i="/$i"
		else i="$PWD/$i"
	fi

	if (( quietLevel < 2 )); then
		if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" ]]; then
			EchoTabs $tabCount; echo -n "Scanning: \""
			if [[ "$(dirname "$i")" == "/" ]]; then echo -n "/"; fi
			echo -n "$(basename "$i")\""
		fi
	fi

	#if (blacklisted)
	for j in "${dirBlacklist[@]}"; do
		#${i:1:SizeOf$j} == $j
		if [[ "${i:1:${#j}}" == "$j" ]]; then
			if (( quietLevel < 2)); then
				if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" ]]; then
					echo -n ": Skipping"
				fi
				if $verbose; then echo -n ": blacklisted"; fi
				echo ""
			fi

			return 1
		fi
	done

	#if ($i is a file)
	if [[ -f "$i" ]]; then
		Backup $tabCount "$i"
		return $?
	fi

	#if (told to check size)
	#if ($checkSize == true)
	if $checkSize; then
		#if (equal or larger than 5g)
		if (( $(CheckSize "$i") > fiveGigabytes )); then
			if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" && "$quietLevel" -lt "2" ]]; then
				local returnBool=false

				echo -e ": Scanning subentries\n"
				DeeperScan true $tabCount "$i" && returnBool=true
				echo ""

				if $returnBool
					then return 0
					else return 1
				fi
			fi

			DeeperScan true $tabCount "$i"
			
			return $?
		fi
	fi

	#if (has blacklisted subdir)
	for j in "${dirBlacklist[@]}"; do
		#/${j:0:SizeOf$i} == $i
		if [[ "/${j:0:$(( ${#i} - 1 ))}" == "$i" ]]; then
			if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" && "$quietLevel" -lt "2" ]]; then
				local returnBool=false

				echo -e ": Scanning subentries\n"
				DeeperScan true $tabCount "$i" && returnBool=true
				echo ""

				if $returnBool
					then return 0
					else return 1
				fi
			fi

			DeeperScan true $tabCount "$i"
			
			return $?
		fi
	done

	#if (is requiredScan dir) or (has requiredScan subdir)
	for j in "${requiredScan[@]}"; do
		#/${j:0:SizeOf$i} == $i
		if [[ "/${j:0:$(( ${#i} - 1 ))}" == "$i" ]]; then
			if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" && "$quietLevel" -lt "2" ]]; then
				local returnBool=false
				
				echo -e ": Scanning subentries\n"
				DeeperScan true $tabCount "$i" && returnBool=true
				echo ""

				if $returnBool
					then return 0
					else return 1
				fi
			fi

			DeeperScan true $tabCount "$i"
			
			return $?
		fi
	done

	Backup $tabCount "$i"
	return $?
}

#returns 0 if (any subdir is backed up)
#returns 1 if (no subdir is backed up)
#param $1 is bool
#param $2 is int
#param $* are arr elements
DeeperScan(){
	local checkSize=$1; shift
	local -i tabCount=$1; shift
	local i="$*"

	local j
	local returnBool=false
	local -a curdirSubdirs 

	cd "$i" || exit 2

	set -o noglob
	mapfile -t curdirSubdirs < <(sudo ls -a)

	for j in "${curdirSubdirs[@]}"; do
		if [[ "$j" == "." ]] || [[ "$j" == ".." ]]; then continue; fi
		
		if Scan $checkSize $((tabCount+1)) "$j"; then returnBool=true; fi

		cd "$i" || exit 2
	done
	
	if $returnBool;
		then return 0
		else return 1
	fi
}

#param $1 is str
CheckSize(){
	local i="$*"

	#if (noByteDU == true)
	if $noByteDU
		then echo "$(( $(sudo du -sk "$i" | awk '{print $1}') * 1024 ))"
		else sudo du -sb "$i" | awk '{print $1}'
	fi
}

#returns 0 if (runs backup)
#returns 1 if (does not run backup)
#param $1 is int
#param $2 is str
Backup(){
	local -i tabCount=$1; shift
	local i="$*"

	#if destination archive (doesn't exist) or (is older than the source)
	if WriteOrNot "$i"; then
		if (( quietLevel < 2 )); then
			if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" ]]; then
				echo ": Backing up"
			fi
		fi

		#if (archive exists)
		if [[ -f "$outputDir$i.tar.$archiveType" ]] && ! $dryRun; then
			sudo rm "$outputDir$i.tar.$archiveType"
		elif [[ -d "$outputDir$i" ]] && ! $dryRun; then
			sudo rm -r "$outputDir$i"
		fi
		
		#if ($i isn't in backupRoot)
		if [[ "$(dirname "$i")" != "$backupRoot" ]] && ! $dryRun; then
			sudo mkdir -p "$outputDir$(dirname "$i")" 2> /dev/null
		fi

		Compress "$i"

		#if ($quietLevel == 0) or ($quietLevel == 1)
		if (( quietLevel < 2 )); then
			if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" ]]; then
				EchoTabs $tabCount; echo -n "Backed up"
				if $verbose; then
					echo -n ": \""
					if [[ "$(dirname "$i")" == "/" ]]; then echo -n "/"; fi
					echo -n "$(basename "$i")\""
				fi
				echo ""
			fi
		fi
		return 0
	fi

	if (( quietLevel < 2)); then
		if [[ -f "$i" && "$quietLevel" -eq "0" ]] || [[ -d "$i" ]]; then
			echo -n ": Skipping"
			if $verbose; then echo -n ": no changes detected. "; fi
			echo ""
		fi
	fi

	return 1
}

#returns 0 if (destination archive does not exist) or (destination archive is older than $source)
#returns 1 if (destination archive is younger than $source)
#param $1 is str
WriteOrNot(){
	local source="$*"

	if [[ ! -f "$outputDir$source.tar.$archiveType" ]]
		then return 0
	fi

	local -i fileTime
	fileTime="$(date -r "$source" "+%Y%m%d%H%M%S")"

	local -i archiveTime
	archiveTime="$(date -r "$outputDir$source.tar.$archiveType" "+%Y%m%d%H%M%S")"

	if (( fileTime > archiveTime));
		then return 0
		else return 1
	fi
}

#param $1 is str
Compress(){
	local i="$*"
	local -i size; size=$(CheckSize "$i")

	totalSize+=$size
	lastBackupSize=$size

	if $dryRun; then return; fi

	lastBackup="$outputDir$i.tar.$archiveType"

	sudo tar --absolute-names --directory "$(sudo dirname "$i")" --create --file - "$(sudo basename "$i")" 2> /dev/null |\
	eval "pv $pvOpts --size $size" |\
	sudo gzip --keep --quiet --best --stdout 2> /dev/null |\
	sudo tee "$outputDir$i.tar.$archiveType" &> /dev/null

	lastBackup=""
	lastBackupSize=0
}

#param $1 is int
EchoTabs(){
	local -i num=$1

	local -i i
	for (( i = 0; i < num; i++ )); do echo -ne "\t"; done
}

#returns 0 if (no options are passed) or (only valid options are passed)
#returns 1 if ("-h" or "--help" is passed) or (an unknown option is passed) 
#param $* are arr elements
GetOpts(){
	local i
	local -i j

	local -a tempArr=()
	local -a optsArr=()
	
	read -ra tempArr <<< "$*"

	for i in "${tempArr[@]}"; do
		if [[ "$i" =~ ^[-]{2,} ]]; then
			while [[ "$i" =~ ^[-]{3} ]]; do
				i="${i:1}"
			done
			optsArr+=("$i")

		elif [[ "$i" =~ ^[-]{1,} ]] && (( ${#i} > 2 )); then
			for (( j = 1; j < ${#i}; j++ )); do
				optsArr+=("-${i:$j:1}")
			done
		else
			optsArr+=("$i")
		fi

	done

	for i in "${optsArr[@]}"; do
		case $i in
			-h|--help)
				DisplayHelp
				return 1
				;;
			-q|--quiet*)
				if (( ${#i} == 2 )); then
					quietLevel+=1
				elif [[ "${i:7}" =~ ^=[0-9]{1,}$ ]]; then
					quietLevel+=${i:8}
				else
					echo -n "Option \"--quiet=\" "
					if [[ "${i:7:1}" != "=" ]] || [[ -z "${i:8}" ]]
						then echo "requires input"
						else echo "only takes integer numbers -- \"${i:8}\""
					fi
					return 1
				fi

				;;
			-s|--simulate|--just-print|--dry-run)
				dryRun=true
				;;
			-v|--verbose)
				verbose=true
				;;
			*)
				if [[ "$i" == "-" ]]; then
					echo "Option not provided -- \"-?\""
				elif [[ "$i" =~ ^[-]{1,} ]]; then
					echo "Option not recognised -- \"$i\""
				else
					echo "Argument not recognised -- \"$i\""
				fi

				return 1
				;;
		esac
	done

	#if ($quietLevel > 0) and ($verbose == true)
	if (( quietLevel )) && $verbose; then
		echo "Cannot pass -v|--verbose and -q|--quiet=NUM"
		return 1
	fi

	if (( quietLevel > 1 ))
		then pvOpts="--quiet"
	elif $verbose
		then pvOpts="--format '%t %e %p %b %r'"
		else pvOpts="--format '%e %p'"
	fi

	return 0
}

#param $1 is bool
#param $2 is int
#param $3 is int if ($1 == true)
#param $* is arr elements
OutputNeatly(){
	local centered=$1
	local -i left=$2; shift 2
	local -a arr=()

	local -i maxArea=0
	local outputStr=""
	local tempStr=""
	local -i spaceInt=0

	local -i i=0
	local -i j=0

	if $centered; then
		maxArea=$(( COLUMNS - ( left * 2 ) ))
	else
		maxArea=$(( COLUMNS - ( left + $1 ) )); shift
		spaceInt=$left
	fi

	IFS=' ' read -ra arr <<< "$*"
	if (( maxArea < 45 )); then maxArea=$COLUMNS; fi

	while (( i < ${#arr[@]} )); do
		tempStr="${arr[$i]}"

		#while (i < arrLen) and ( (outputStrLen + 1 + tempStrLen) < maxArea )
		while (( i < ${#arr[@]} )) && (( ( ${#outputStr} + 1 + ${#tempStr} ) < maxArea )); do
			if [[ -n "$outputStr" ]]; then outputStr+=" "; fi
			outputStr+="$tempStr"

			i+=1
			tempStr="${arr[$i]}"
		done

		if [[ -n "$outputStr" ]]; then
			if $centered; then
				spaceInt=$(( ( ( left * 2 ) + maxArea - ${#outputStr} ) / 2 ))
			fi

			for (( j=0; j<spaceInt; j++ )); do echo -n " "; done
			echo "$outputStr"
			
			outputStr=""
		fi
	done
}

DisplayHelp(){
		OutputNeatly true 5 "Flexible Backup"
	echo ""
		OutputNeatly true 5 "$(HelpText "description")"
			
	echo -e "Options:\n"

	echo "    -h, --help:"
		OutputNeatly false 10 5 "$(HelpText "help")"
	echo ""
	echo "    -q, --quiet:"
		OutputNeatly false 10 5 "$(HelpText "quiet")"		
	echo ""
	echo "    -s, --simulate, --dry-run, --just-print:"
		OutputNeatly false 10 5 "$(HelpText "simulate")"
	echo ""
	echo "    -v, --verbose:"
		OutputNeatly false 10 5 "$(HelpText "verbose")"	
	echo ""
}

#param $1 is str
HelpText(){
	case "$1" in
		"description")
			echo -n "Creates backups more representative of the system "
			echo -n "at time of backup by only backing up updated files"
			echo -n " and directories"
			;;
		"quiet")
			echo -n "Silences program in levels increased by passing mu"
			echo -n "ltiple instances of '-q' and/or '--quiet=NUM'. Lev"
			echo -n "el 1silences scanning/skipping message for non-dir"
			echo -n "ectory source, message when source is blacklisted,"
			echo -n " and announcement of when source is about to be ba"
			echo -n "cked up. Level 2 or higher silences every message "
			echo -n "and causes the program to make no output. Cannot b"
			echo -n "e passed with -v or --verbose."
			;;

		"verbose")
			echo -n "Increases verbosity of output. Gives bitrate, tota"
			echo -n "l amount transferred, and timer with the compressi"
			echo -n "on progress bar and stat es reason for why specifi"
			echo -n "c source was skipped. Can not be passed with -q or"
			echo -n " --quiet."
			;;

		"help")
			echo -n "Displays this message."
			;;
		"simulate")
			echo -n "Disable backing up and removal of outdated package"
			echo -n "s, while still giving an estimated readout of size"
			echo -n " of the backup"
			;;
	esac
}

#returns 0 if ($conf file exists)
#returns 1 if ($conf file does not exits)
CheckConf(){
	if [[ -f "$conf" ]];
		then ReadConf; return 0
		else MakeConf; return 1
	fi
}

ReadConf(){
	source "$HOME/.config/flexible-backup.conf"

	IFS=","

	backupRoot="$BackupRootDir"
	if [[ "${backupRoot:0:1}" != "/" ]]; then backupRoot="/$backupRoot"; fi
	if [[ "${backupRoot:0-1}" == "/" ]] && [[ "$backupRoot" != "/" ]]; then
		backupRoot="${backupRoot:0:0-1}"
	fi
	
	outputDir="$OutputLocation"
	if [[ "${outputDir:0:1}" != "/" ]]; then outputDir="/$outputDir"; fi
	if [[ "${outputDir:0-1}" == "/" ]] && [[ "$outputDir" != "/" ]]; then
		outputDir="${outputDir:0:0-1}"
	fi

	read -ra dirWhitelist <<< "$Whitelist"
	for i in "${!dirWhitelist[@]}"; do
		if [[ "${dirWhitelist[i]:0:1}" == "/" ]]; then dirWhitelist[i]="${dirWhitelist[$i]:1}"; fi
		if [[ "${dirWhitelist[i]:0-1}" == "/" ]]; then dirWhitelist[i]="${dirWhitelist[$i]:0:0-1}"; fi
	done

	read -ra dirBlacklist <<< "$Blacklist"
	for i in "${!dirBlacklist[@]}"; do
		if [[ "${dirBlacklist[i]:0:1}" == "/" ]]; then dirBlacklist[i]="${dirBlacklist[$i]:1}"; fi
		if [[ "${dirBlacklist[i]:0-1}" == "/" ]]; then dirBlacklist[i]="${dirBlacklist[$i]:0:0-1}"; fi
	done
	dirBlacklist+=("${outputDir:1}")

	read -ra requiredScan <<< "$SplinteredBackupRequired"
	for i in "${!requiredScan[@]}"; do
		if [[ "${requiredScan[i]:0:1}" == "/" ]]; then requiredScan[i]="${requiredScan[i]:1}"; fi
		if [[ "${requiredScan[i]:0-1}" == "/" ]]; then requiredScan[i]="${requiredScan[i]:0:0-1}"; fi
	done
	
	unset BackupRoot
	unset OutputLocation
	unset Whitelist
	unset Blacklist
	unset SplinteredBackupRequired
}

MakeConf(){
	sudo touch "$conf"
	ConfFormat | sudo tee "$conf" &> /dev/null
	sudo chmod 600 "$conf"
	sudo chown "$USER:$USER" "$conf"

	echo "Config file made and edited at \"$conf\""
}

ConfFormat(){
	echo "#The directory the program considers the root of the backup"
	echo "#If unknown, leave as '/'"
	echo -e "BackupRootDir=/\n"
	echo "#Files and directories that should be backed up under the BackupRoot"
	echo "#Separate entries by comma"
	echo -e "Whitelist=/home\n"
	echo "#Directories that won't be made into a single archive even if smaller than 5gb"
	echo "#Archives will be made of all the entries in the directory specifically instead of one big archive"
	echo "#Good for directories with constantly updating files like /bin"
	echo -e "SplinteredBackupRequired=/home,\$HOME\n"
	echo "#Files and directories that will be excluded"
	echo -e "Blacklist=/home/lost+found,\$HOME/.cache,\$HOME/.local/share/Trash\n"
	echo "#Specify where files should be sent after backup"
	echo -e "OutputLocation=\$HOME/flexible_backup\n"
}

#returns number of missing dependencies
CheckDependancies(){
	local missing=""
	#if (specific binary does not exist)
	if [[ ! -f /usr/bin/tar ]]; then missing+="tar "; fi
	if [[ ! -f /usr/bin/gzip ]]; then missing+="gzip "; fi
	if [[ ! -f /usr/bin/pv ]]; then missing+="pv "; fi

	#if (there are missing binary/ies)
	if [[ -n "$missing" ]]; then
		echo -e "Missing dependencies: ${missing:0:0-1}\nStopping program"
	fi

	return "$(echo "$missing" | wc -w)"
}

GetTotalSizeBackedUp(){
	local -i i=0
	local -i int=0
	local units=""

	if $noByteDU; then int=1; fi

	while (( totalSize >= 1024 )); do
		decimalOfTotalSize=$(( totalSize % 1024 ))
		totalSize=$(( totalSize / 1024 ))
		int+=1
		if (( int == 3 )); then break; fi
	done

	decimalOfTotalSize=${decimalOfTotalSize:0:$sigFigs}

	case $int in
		0) units=""       ;;
		1) units="kilo"   ;;
		2) units="mega"   ;;
		3) units="giga"   ;;
		4) units="tera"   ;;
		5) units="peta"   ;;
		6) units="exa"    ;;
		*) units="alotta" ;;
	esac

	echo -n "Roughly $totalSize"
	if (( decimalOfTotalSize )); then
		echo -n ".${decimalOfTotalSize:0:$sigFigs}"

		for ((i=0;i<$(( sigFigs - ${#decimalOfTotalSize} ));i++)); do
			echo -n "0"
		done

	fi

	echo -n " $units""byte"
	if (( totalSize + decimalOfTotalSize > 1 )) || (( ! totalSize + decimalOfTotalSize )); then
		echo -n "s"
	fi
	if $dryRun; then echo -n " would have been"; fi
	echo " backed up"
}

# shellcheck disable=SC2317
SIGINT_Trap(){
	echo "Program canceled"
	totalSize=$(( totalSize - lastBackupSize ))
	if [[ -n "$lastBackup" ]] && ! $dryRun; then
		if [[ -f "$lastBackup" ]]; then
			echo -e "\tCleaning up \"$lastBackup\""
			sudo rm "$lastBackup"
		fi
		echo "Finishing up..."
	fi

	sudo chown -R "$USER:$USER" "$outputDir"
	
	GetTotalSizeBackedUp

	tput cnorm
}

#returns 0 if (user is root) or (user executes sudo)
#returns 1 if (user cannot execute sudo) or (user does not execute sudo)
SudoCheck(){
	if [[ "$(whoami)" != "root" ]]; then
		(sudo -l &> /dev/null) && sudo echo -n "" && return 0

		echo -e "Error: requires sudo privileges\n"; return 1
	fi
	return 0
}

#has program handle SIGINT itself
trap 'SIGINT_Trap;exit 1' SIGINT

tput civis
CheckDependancies && SudoCheck && CheckConf && GetOpts "$@" && main
tput cnorm
exit $?
